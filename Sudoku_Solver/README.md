# 数独问题

了解数独游戏的逻辑性，我读了这篇[博客](https://blog.csdn.net/only_me_canthis/article/details/123800468)和这篇[论文](https://max.book118.com/html/2016/0507/42155092.shtm)。

## 数独题目生成思路

出题有两种思维模式，一种是挖空出题，一种是空盘出题。

1. **挖空出题**：先找到一个终盘（也就是答案盘），然后挖出其中的提示数，然后自己尝试去解题，发现多解之后，再多添加一些候选数即可。

2. **空盘出题**：先在一个空盘面之内，找到一些位置，用来放提示数，然后随便写数字，采用“边写边解”的方式，来进行出题。矛盾了就“回溯”，即倒退。

可以参考[多次求解比对法](https://www2.zhihu.com/question/381719541)和[挖空出题](https://blog.csdn.net/any_ways/article/details/128063742?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128063742-blog-106110737.235^v43^control&spm=1001.2101.3001.4242.1&utm_relevant_index=3)。

## 实现代码

- **Sudoku.c**：数独题目生成器，利用终端命令 `./Sudoku N` 执行，其中 N 为数独个数。
  
  运行方法：
  ```shell
  gcc -o Sudoku Sudoku.c 
  ./Sudoku 1000000
  ```

- **Sudoku_Solver.c**：数独求解器。

- **Sudoku_Test.c**：答案测试器。

## 代码参考

本项目中的数独求解器参考了这篇[C++数独生成](https://blog.csdn.net/any_ways/article/details/128063742?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128063742-blog-106110737.235^v43^control&spm=1001.2101.3001.4242.1&utm_relevant_index=3)代码。

# 并行数独求解器

这个项目旨在利用并行处理来解决数独问题，以提高解决问题的效率。以下是一些关键要点：

- 并行任务：每个猜测（guess）都被视为一个独立的任务，可以并行处理。这意味着可以将每个猜测分配给一个单独的线程或任务来处理，从而加速解决问题的过程。
- 避免同一板上的冲突：在解决数独问题时，同一数独棋盘上的两个任务不能同时进行。这是因为每个任务都会对同一数独棋盘进行更改，如果同时进行可能会导致数据竞争和不确定的结果。
- 任务取消：当找到解决方案时，不应再发出更多的任务，并且应取消先前发出的任务。这是为了避免浪费计算资源并提高效率。
- 内部任务创建可以在任务内部创建更多的任务，以确保线程池中始终有足够的工作量。但是，应该避免创建过小的任务，因为这可能会增加内存和任务管理的开销。

## 解题思路

### DFS并行

[DFS的并行代码](https://cloud.tencent.com/developer/ask/sof/106302496)实现了递归代码的并行，但是不具有本任务中的回溯性质。

### 艰难求解回溯算法并行

尝试参考这个利用OpenMP解决[N皇后问题](https://z-rui.github.io/post/2015/11/openmp/)的代码，它同样基于回溯算法实现。

并行计算的思考，以[回溯法求解数独问题](https://www.cnblogs.com/wangyaning/p/7853932.html)为例。

参考[并行巨型数独求解器](https://clairewangyuyue.github.io/CS205_G1.github.io/)。

多次尝试自行利用OpenMP并行无果后，发现[在解数独问题时，将回溯算法并行化并不能提高CPU利用率](https://www.volcengine.com/theme/7581947-Z-7-1)。

甚至在其他完整的[并行数独求解器](https://github.com/huaminghuangtw/Parallel-Sudoku-Solver)项目中，也没有给出基于回溯算法的并行，而是基于暴力求解法和DLX法的并行。

这个[回溯算法数独的并行](https://github.com/vduan/parallel-sudoku-solver)项目告诉我，这种回溯算法和一般的深度优先搜索似乎不太能并行，因为它们依赖于堆栈。这使得并行化变得困难，因为线程无法有效地在同一个堆栈上同时工作，而不会导致堆栈访问的竞争条件太过频繁。

### 深度优先搜索并行化

我们可以对深度优先搜索方法进行修改，使线程能够独立地执行，而不是都从同一个堆栈中读取。广度优先搜索很容易并行化，因此我们可以首先找到填充给定谜题的前 20 个空格的所有可能有效的棋盘。这可能会给我们带来成千上万个可能的棋盘。然后，这些棋盘可以传递给另一个内核，其中每个线程将其自己的棋盘应用于回溯算法。如果任何线程找到解决方案，所有线程都停止，该解决方案传回给 CPU。

我们可以看到，这两个步骤比原始的深度优先搜索解决方案更容易并行化。最终，这是我们选择关注的主要方法。


### 其他方案：模拟退火算法

模拟退火算法是一种基于统计力学中退火过程的随机优化算法。它模拟了固体物体加热后冷却的过程，在搜索空间中随机游走以找到全局最优解或近似最优解。这个算法常被用来解决组合优化问题。

算法的基本思想是，开始时接受较大的概率来接受一个劣质解，然后随着时间的推移逐渐降低接受劣质解的概率，从而使搜索更加专注于局部区域。这个过程允许算法在搜索空间中跳出局部最优解，以期望找到全局最优解。

**模拟退火解决数独变体**：首先在数独板上填充数字。这些数字不必位于正确的位置，但棋盘上1-9中的每个数字应该正好有9个。此外，每个3x3子板都应包含1-9中的所有数字。

这个算法是一个并行化的方法，用于解决数独难题。它的基本思想是先随机填充数独棋盘，然后通过随机交换两个非固定数字来尝试改善棋盘的状态。如果新的棋盘状态更好（根据评分系统），则保留它；否则，以一定概率回退到原来的状态。这里的“更好”是指棋盘的评分更接近解决方案的标准评分。

1. **随机选择两个非固定数字并交换它们的位置**：这个步骤通过随机选择一个子框并交换其中的两个数字来改变棋盘的状态。

2. **评估棋盘状态**：通过评分系统来计算当前棋盘状态的得分，评分方法可以基于每行、每列和每个子框中的唯一数字数量来进行评估。

3. **比较新旧状态**：比较新状态与旧状态的得分。如果新状态更好，则接受它；否则，根据一定的概率接受新状态或者继续保持旧状态。

4. **重复迭代**：重复以上步骤，直到达到终止条件或找到解决方案。

由于许多交换可能不会相互干扰（尤其是位于不同子框中的交换），并且交换顺序通常没有实际意义，因此这种方法非常适合并行化处理，尤其是在 GPU 上执行。

## 并行回溯算法

### 回溯内核并行

此内核将期望以下内容，通过计算实现：

- 要搜索的所有棋盘
- 要搜索的棋盘数量

然后，该内核将生成线程，每个线程分别处理一个棋盘。它将按照之前描述的经典回溯算法执行。

代码：backtrack_kernel.c

当要执行的数独数目等于10000时，程序崩溃，程序没有足够的内存来存储所有的数独问题和解决方案。这个程序会一次性读取所有的数独问题到内存中，然后再一次性写入所有的解决方案。如果你的数独问题数量非常大，可能会导致程序耗尽所有可用内存。

当./Sudoku 1000时
(base) PS E:\Documents\2-UU\High Performance Programming\HPP\Sudoku_Solver> ./omp 1      
Time taken: 0.010000 seconds
(base) PS E:\Documents\2-UU\High Performance Programming\HPP\Sudoku_Solver> ./omp 16
Time taken: 0.006000 seconds

### 放弃使用堆栈

int unAssignInd[BoardSize * BoardSize];：这是一个一维数组，用于存储尚未分配的单元格的索引。在数独游戏中，这些索引用于标识尚未填入数字的空白格的位置。

int N_unAssign = 0;：这是一个整数变量，用于跟踪未分配的单元格数量。它被用于确定尚未分配的单元格索引数组中的有效元素数量。

参考[这个](https://stackoverflow.com/questions/65795427/parallelizing-backtrack-on-sudoku-not-increasing-the-cpu-utilized)成功实现回溯并行的C++代码，发现它用动态查询代替了堆栈。可以成功运行，但在从C++部署到C上出现了无法解决的问题。

同样有[C语言](https://stackoverflow.com/questions/68320530/openmp-sudoku-solver-parallelize-algorithm-with-openmp-and-or-mpi)版本，但是没有讨论出一个可行方案。

非常复杂的[数独并行求解器](https://github.com/Shivanshu-Gupta/Parallel-Sudoku-Solver/blob/master/src/sudoku.c)。

看起来他们实现了利用C++[某种回溯并行](https://github.com/maijoshi/ParaSudoku)。